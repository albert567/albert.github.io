<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot入门]]></title>
    <url>%2Fspringboot%2F</url>
    <content type="text"><![CDATA[本文转载自 https://www.cnblogs.com/wmyskxz/p/9010832.html Spring Boot 概述 Build Anything with Spring Boot：Spring Boot is the starting point for building all Spring-based applications.Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring. 上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来。Spring 应用程序并且尽可能减少你的配置文件。 什么是 Spring Boot 它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。 它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot整合了所有框架（引自：springboot(一)：入门篇——纯洁的微笑） 使用 Spring Boot 有什么好处回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要： 1）配置 web.xml，加载 spring 和 spring mvc 2）配置数据库连接、配置日志文件 3）配置家在配置文件的读取，开启注解 4）配置mapper文件 ….. 而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了… 划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。 Spring Boot 快速搭建第一步：新建项目选择 Spring Initializr ，然后选择默认的 url 点击【Next】：然后修改一下项目的信息：勾选上 Web 模板：选择好项目的位置，点击【Finish】：如果是第一次配置 Spring Boot 的话可能需要等待一会儿 IDEA 下载相应的 依赖包，默认创建好的项目结构如下：项目结构还是看上去挺清爽的，少了很多配置文件，我们来了解一下默认生成的有什么： SpringbootApplication： 一个带有 main() 方法的类，用于启动应用程序 SpringbootApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的 Spring 应用程序上下文 application.properties：一个空的 properties 文件，可以根据需要添加配置属性 pom.xml： Maven 构建说明文件 第二步：HelloController在【cn.altctrl.springboot】包下新建一个【HelloController】：12345678910111213package cn.altctrl.springboot;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/hello&quot;) public String hello() &#123; return &quot;Hello Spring Boot!&quot;; &#125;&#125; @RestController 注解： 该注解是 @Controller 和 @ResponseBody 注解的合体版 第三步：利用 IDEA 启动 Spring Boot我们回到 SpringbootApplication 这个类中，然后右键点击运行： 注意：我们之所以在上面的项目中没有手动的去配置 Tomcat 服务器，是因为 Spring Boot 内置了 Tomcat等待一会儿就会看到下方的成功运行的提示信息： 可以看到我们的 Tomcat 运行在 8080 端口，我们来访问 “/hello” 地址试一下： 可以看到页面成功显示出我们返回的信息。]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis相关]]></title>
    <url>%2Fredis%2F</url>
    <content type="text"><![CDATA[介绍：Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API的非关系型数据库。传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 CAP 定理。Github 源码：https://github.com/antirez/redisRedis 官网：https://redis.io/ Redis支持的数据类型？String字符串格式: set key valuestring类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，一个键最大能存储512MB。 Hash（哈希）格式: hmset name key1 value1 key2 value2Redis hash 是一个键值(key=&gt;value)对集合。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）格式: lpush name value在 key 对应 list 的头部添加字符串元素格式: rpush name value在 key 对应 list 的尾部添加字符串元素格式: lrem name indexkey 对应 list 中删除 count 个和 value 相同的元素格式: llen name返回 key 对应 list 的长度 Set（集合）格式: sadd name valueRedis的Set是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 zset(sorted set：有序集合)格式: zadd name score valueRedis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。 什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis 提供了两种持久化方式:RDB（默认） 和AOFRDB：rdb是Redis DataBase缩写功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数AOF:Aof是Append-only file缩写每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作aof写入保存：WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。存储结构: 内容是redis通讯协议(RESP )格式的命令文本存储。 比较：1、aof文件比rdb更新频率高，优先使用aof还原数据。2、aof比rdb更安全也更大3、rdb性能比aof好4、如果两个都配了优先加载AOF 刚刚上面你有提到redis通讯协议(RESP )，能解释下什么是RESP？有什么特点？（可以看到很多面试其实都是连环炮，面试官其实在等着你回答到这个点，如果你答上了对你的评价就又加了一分）RESP 是redis客户端和服务端之前使用的一种通讯协议；RESP 的特点：实现简单、快速解析、可读性好For Simple Strings the first byte of the reply is “+” 回复For Errors the first byte of the reply is “-“ 错误For Integers the first byte of the reply is “:” 整数For Bulk Strings the first byte of the reply is “$” 字符串For Arrays the first byte of the reply is “*” 数组 Redis 有哪些架构模式？讲讲各自的特点单机版 特点：简单问题：1、内存容量有限 2、处理能力有限 3、无法高可用。主从复制Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。特点：1、master/slave 角色2、master/slave 数据相同3、降低 master 读压力在转交从库问题：无法保证高可用没有解决 master 写的压力 哨兵Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。特点：1、保证高可用2、监控各个节点3、自动故障迁移缺点：主从模式，切换需要时间丢数据没有解决 master 写的压力 集群（proxy 型）：Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。特点：1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins2、支持失败节点自动删除3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致缺点：增加了新的 proxy，需要维护其高可用。failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预 集群（直连型）：从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。 特点：1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。缺点：1、资源隔离性较差，容易出现相互影响的情况。2、数据通过异步复制,不保证数据的强一致性 什么是一致性哈希算法？什么是哈希槽？这两个问题篇幅过长 网上找了两个解锁的不错的文章https://www.cnblogs.com/lpfuture/p/5796398.htmlhttps://blog.csdn.net/z15732621582/article/details/79121213 Redis常用命令？Keys pattern*表示区配所有以bit开头的查看Exists key是否存在Set设置 key 对应的值为 string 类型的 value。setnx设置 key 对应的值为 string 类型的 value。如果 key 已经存在，返回 0，nx 是 not exist 的意思。删除某个key第一次返回1 删除了 第二次返回0Expire 设置过期时间（单位秒）TTL查看剩下多少时间返回负数则key失效，key不存在了Setex设置 key 对应的值为 string 类型的 value，并指定此键值对应的有效期。Mset一次设置多个 key 的值，成功返回 ok 表示所有的值都设置了，失败返回 0 表示没有任何值被设置。Getset设置 key 的值，并返回 key 的旧值。Mget一次获取多个 key 的值，如果对应 key 不存在，则对应返回 nil。Incr对 key 的值做加加操作,并返回新的值。注意 incr 一个不是 int 的 value 会返回错误，incr 一个不存在的 key，则设置 key 为 1incrby同 incr 类似，加指定值 ，key 不存在时候会设置 key，并认为原来的 value 是 0Decr对 key 的值做的是减减操作，decr 一个不存在 key，则设置 key 为-1Decrby同 decr，减指定值。Append给指定 key 的字符串值追加 value,返回新字符串值的长度。Strlen取指定 key 的 value 值的长度。persist xxx(取消过期时间)选择数据库（0-15库）Select 0 //选择数据库move age 1//把age 移动到1库Randomkey随机返回一个keyRename重命名Type 返回数据类型 使用过Redis分布式锁么，它是怎么实现的？先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！ 使用过Redis做异步队列么，你是怎么用的？有什么缺点？一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。能不能生产一次消费多次呢？使用pub/sub主题订阅者模式，可以实现1:N的消息队列。 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？缓存穿透一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。如何避免？1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。 缓存雪崩当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。如何避免？1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>Key-Value数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码篇]]></title>
    <url>%2Fhashmap%2F</url>
    <content type="text"><![CDATA[本文转载自 https://www.cnblogs.com/zhaojj/p/7805376.html 目的：单纯分析和学习hashmap的实现，不多说与Hashtable、ConcurrentHashMap等的区别。基于 jdk1.8 在面试中有些水平的公司比较喜欢问HashMap原理，其中涉及的点比较多，而且大多能形成连环炮形式的问题。 一般连环炮，一环不知道后面试官也就不问了，但是低层连环没连上，恭喜扣分是大大的，连到比较深的时候，说不知道还好点，比如： 关于集合的1.1Hashmap是不是有序的？ 不是继续 1.2有没有有顺序的Map？ TreeMap LinkedHashMap 1.3它们是怎么来保证顺序的？ 一般都要说到其源码，要不说不清为么有序 1.4答两个有序或以上的 继续 你觉得它们有序的区别，那个比较好，在什么场景用哪个好？ 1.4答一个也可以问上面的场景 继续 1.5你觉得有没有更好或者更高效的实现方式？有 1.6 答有 这个时候说起来可能就要跑到底层数据结构上去了 数据结构继续衍生 到 算法等等。。。 就这一个遇到大佬问你，能把很多人连到怀疑人生 2.关于hash的 1.1 hashmap基本的节点结构？ Node 键值对 1.2 键是什么样的，我用字符串a那键就是a嘛？ 不是会进行hash 1.3 如何hash的 这样hash有什么好处？ 源码hashmap的hash算法 1.4 Hash在java中主要作用是什么？ 1.5 Hashcode equal相关 需要同时重写？原因？ 1.6 equal引出的对象地址、string带有字符串缓冲区、字符串常量池 等等。。。 3.关于线程安全问题、到concurrent包等 前面说这些就是想说，hashmap中用到的东西很多，深入学习和理解对每个想晋升的程序员来说基本是必须，同时由它引出的对比，也是无限多，有很大的必要学习。 HashMap类加载1.只有一些静态属性会进行赋值，具体每个值什么用，暂时不管 1234567891011static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;static final int MIN_TREEIFY_CAPACITY = 64; 开始使用，第一步我们肯定是初始化方法，先从默认的构造方法开始学习12345678public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125;1.AbstractMap父类，构造方法也没干事不谈2.只是赋值loadFactor 0.75f 没干别的事3.static final float DEFAULT_LOAD_FACTOR = 0.75f;4.loadFactor属性 作用先放着后面用到再看5.没干别的事了 一般我们的使用第二步就是put了先看常用的put键值对，这个学完了，那么其他的put方法就没什么问题了，比如putAll、putIfAbsent、putMapEntries 同时put弄明白了 取值就是一个反向就简单了 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125; 1.先对key进行hash计算，学一下 1234567891011static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;1.1 看出key是可以空的 hash为01.2 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) 第一步取key的hashcode值 关于更底层的hashcode是什么 有兴趣再看 h ^ (h &gt;&gt;&gt; 16) 第二步 高位参与运算这个hash值的重要性就不说了，这里这么干是出于性能考虑，底层的移位和异或运算肯定比加减乘除取模等效率好 hashcode是32位的，无符号右移16位，那生成的就是16位0加原高位的16位值， 就是对半了，异或计算也就变成了高16位和低16位进行异或，原高16位不变。这么干主要用于当hashmap 数组比较小的时候所有bit都参与运算了，防止hash冲突太大，所谓hash冲突是指不同的key计算出的hash是一样的，比如a和97，这个肯定是存在的没毛病 2.putVal 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&apos;t change existing value 相同key是不是覆盖值 * @param evict if false, the table is in creation mode. 在hashmap中没用 * @return previous value, or null if none */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 2.1 执行顺序 第一句 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; 申明变量 Node是啥,学习一下： static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 是内部的一个静态类，看看就明白了，明显是一个带有3个值，hash、key、value和另一个Node对象引用的HashMap子元素结构，即我们装的每个键值对就用一个Node对象存放 第二句 if ((tab = table) == null || (n = tab.length) == 0) 这句 tab = table赋值，table现在是null的，so n = tab.length不运行了 运行这个if的代码块 第三句 n = (tab = resize()).length; 从下面的执行知道 n=16 调用resize()，返回Node数组，这个resize是一个非常重要的方法，我们就依现在的对象状态去看这个方法，不带入其他状态，认真研究学习下 final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; resize 1.Node&lt;K,V&gt;[] oldTab = table; 在上面知道table是null的，so oldTab也是null 2.int oldCap = (oldTab == null) ? 0 : oldTab.length; oldCap=0 3.int oldThr = threshold; threshold我们没赋值过，int初始0 ， oldThr=threshold=0 4.int newCap, newThr = 0; 不谈 5.if (oldCap &gt; 0) &#123; oldCap=0 if不运行 6.else if (oldThr &gt; 0) oldThr=0 if也不运行 7.else &#123; newCap = DEFAULT_INITIAL_CAPACITY; DEFAULT_INITIAL_CAPACITY静态成员变量，初始 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 so newCap=16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); static final float DEFAULT_LOAD_FACTOR = 0.75f; 0.75*16=12 newThr=12 &#125; 8. if (newThr == 0) &#123; newThr=12 if不运行 9. threshold = newThr; threshold = newThr=12 10. Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap] 申明一个16个大小的Node数组 11. table = newTab; 看出来了吧，table是成员变量，也就表明，HashMap初始数据结构是一个16的Node数组 12. if (oldTab != null) &#123; oldTab是1中赋值的null，if不运行 13. return newTab; 返回16大小的node数组 总结，这一波调用是初次调用其实没干别的事，就是定义了基本的数据结构是16个Node数组，但是这个方法不简单，因为一些if没走 第四句 if ((p = tab[i = (n - 1) &amp; hash]) == null) n=16 15&amp;hash 结果肯定是0-15，这里就看出，这是在计算一个key应该在整个数据结构16的数组中的索引了，并赋值给i变量，后面不管整体结构n变多大，这种计算key所在的索引是非常棒的设计。 现在的状态是初始的 肯定是null的吧 if运行 第五句 tab[i] = newNode(hash, key, value, null); new一个节点Node，放在数组里，i是第四句计算的索引 第六句 else &#123; 不运行 第七句 ++modCount; transient int modCount; 根据注释可以看出，这个是记录数据结构变动次数的，put值肯定是变了的 第八句 if (++size &gt; threshold) size=1 threshold在调用resize时赋值12 if不运行 第九句 afterNodeInsertion(evict); 没干事 第十句 return null; 不谈 3.putVal 再回头详走,第一遍干了很多初始化的事有些东西还没研究到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 第一句 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; 申明变量不谈 第二句 if ((tab = table) == null || (n = tab.length) == 0) 这句 tab = table赋值，table现在是16数组 n=16 if不运行 第三句 if ((p = tab[i = (n - 1) &amp; hash]) == null) 再看就知道了判断当前存的key计算出的索引位置是不是已经存过值了 没存过就新Node存 和上面一遍一样 我们当已经有值了 有值其实就意味着发生hash冲突了 比如key分别是a和97 hashCode都是97 冲突 因此这次我们主要看下一个else里面HashMap是怎么处理冲突的 第四句 else中内容 即冲突处理 p是冲突时数组该索引位置的元素 1. p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))) 判断新元素hash和key是不是都和p相同，相同表示存了一样的key 直接赋值给e 2. p instanceof TreeNode（红黑树，具体的红黑树算法这里就不详细写了，有兴趣可以去学习） 怎么猛然来个红黑树，再3里说 判断原来元素是不是 TreeNode 类型 TreeNode一样是静态内部类，再看看就是红黑树的节点，因此这个地方用到了红黑树 putTreeVal 向红黑树中添加元素 内部实现，存在相同key就返回赋值给e 不存在就添加并返回null 源码就是红黑树算法 3.key不同也不是红黑树 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); &#125; 先不看再里面的那个if，这个一看就知道了吧，明显的链表啊，而且数据里的这个元素是链表头 整个循环，明显是在从头开始遍历链表，找到相同key或链表找完了新元素挂链表最后 但在其中还有这么个if if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; 这是在链表找完了，且新元素已经挂在链表最后了有的一个判断 判断循环次数，其实就是链表长度，长度超过TREEIFY_THRESHOLD 默认8则运行treeifyBin(tab, hash); 就是这个方法把链表变成红黑树了，具体方法源码不谈了，学红黑树就可以了 最后判断e是不是空，上面的冲突方案看出e不是空就是表示有相同的key进行value覆盖就可以，e空就是无相同key且完成了数据挂载 总结这次再走一遍putVal就是为了学习HashMap的冲突处理方案，也看出内存结构是数组、链表、红黑树组成的，红黑树是java8新引进，是基于性能的考虑，在冲突大时，红黑树算法会比链表综合表现更好 4.resize 再详走 putVal最后一段size&gt;threshold threshold初始12 ++size元素数量肯定会有超12个的时候，这里也就看出了threshold代表HashMap的容量，到上限就要扩容了，默认现在16数组，12元素上限 1234567891011121314151617181920212223241.Node&lt;K,V&gt;[] oldTab = table; 16大小 2.int oldCap = (oldTab == null) ? 0 : oldTab.length; oldCap=16 3.int oldThr = threshold; 12 4.int newCap, newThr = 0; 不谈 5.if (oldCap &gt; 0) &#123; oldCap=16运行 oldCap是整体结构数组大小 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; 判断数组大小是不是已经到上限1&lt;&lt;30 threshold = Integer.MAX_VALUE; 到达上线 threshold 赋值最大值 然后返回 表示之后就不再干别的事了，随便存，随便hash冲突去，就这么大，无限增加红黑树节点了 return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) 赋值newCap为2倍数组大小，判断如果扩充2倍有没到上限，且不扩充时容量是否大于默认的16 newThr = oldThr &lt;&lt; 1; // double threshold 满足则赋值 容量改为24 &#125; 这段看出到threshold容量了就进行2倍扩容 6.if (newThr == 0) &#123; 如果运行该if 0 表示5步中扩容2倍到上限或原数组大小小于16 float ft = (float)newCap * loadFactor; newCap现在是2倍原大小的*0.75 2倍数组大小时的容量 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); 判断2倍数组大小和2倍后的容量是不是都小于最高值，是则赋值新容量，不是就用整形最大值 &#125; 7. threshold = newThr; 把5 6两步算出的新容量赋值给HashMap 也说明要扩容了 8. Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; 和后面的循环主要就是把原数组中的元素，一个一个添加到新数组中，转移的一个过程 总结，这一波调用是了解HashMap的扩容方式，看下来就是2倍扩容直到上限 5.总结，到这put就比较详细了，也知道了基本结构是数组、链表、红黑树，链表到8个时转换成红黑树同时每次进行2倍扩容和数据转移，扩容是用新结构的那显然减少扩容次数会有更好的性能那就要求每次声明HashMap时最好是指定大小的 一些其他我们需要知道的1.指定大小的初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; 第一个常用，第二个建议是不用，不去动0.75的这个容量比例，当然不绝对 这里tableSizeFor是一个很神奇的算法，我非常佩服的一个算法 static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 这个方法是在找大于等于cap且最小2的幂 比如cap=1 结果 2 0次方 1 cap=2 2 cap=3 4 cap=9 16 分析下等于9 cap - 1 第一步结果8 00000000000000000000000000001000 8 00000000000000000000000000000100 右移1位 00000000000000000000000000001100 或运算 结果 00000000000000000000000000000011 右移2位 00000000000000000000000000001111 或运算 结果 00000000000000000000000000001111 右移 4 8 16没用全是0结果还是这个15 最终 +1 16 分析下等于大点 12345678 00000000101111000110000101001110 12345678 00000000101111000110000101001101 -1结果 12345677 00000000010111100011000010100110 右移1位 00000000111111100111000111101111 或运算 结果 00000000001111111001110001111011 右移2位 00000000111111111111110111111111 差不多了在移0就没了都是1了，+1不是肯定是2的倍数了 再说开始-1原因这是为了防止，cap已经是2的幂。 如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看 2.HashMap数组结构为什么用2的倍数高速的索引计算，使用HashMap肯定是冲突越少越好，就要求分部均匀，最好的用取模 h % length，但是近一步如果用2的幂h &amp; (length - 1) == h % length 是等价的，效率缺差却别非常大综合衡量用空间换了时间，且是值得的 3.线程安全问题线程不安全，就put来看全程没考虑线程问题，肯定不安全，现在随便并发一下resize会混乱吧，put链表，红黑树挂载基本都会出问题]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HttpClient工具类]]></title>
    <url>%2Fhttpclient%2F</url>
    <content type="text"><![CDATA[引用自&gt; https://my.oschina.net/u/873047/blog/204634所需jar包： commons-cdec-1.9.jar commons-logging-1.2.jar fluent-hc-4.5.2.jar httpclient-4.5.2.jar httpclient-cache-4.5.2.jar httpclient-win-4.5.2.jar httpcore-4.4.4.jar httpmime-4.5.2.jar jna-4.1.0.jar jna-platform-4.1.0.jar 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import java.util.ArrayList;import java.util.List;import java.util.Map;import org.apache.http.HttpEntity;import org.apache.http.NameValuePair;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClientBuilder;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;public class HttpRequestUtils &#123; private static final CloseableHttpClient httpClient; public static final String CHARSET = &quot;UTF-8&quot;; static &#123; RequestConfig config = RequestConfig.custom().setConnectTimeout(60000).setSocketTimeout(15000).build(); httpClient = HttpClientBuilder.create().setDefaultRequestConfig(config).build(); &#125; public static String doGet(String url, Map&lt;String, String&gt; params)&#123; return doGet(url, params,CHARSET); &#125; public static String doPost(String url, Map&lt;String, String&gt; params)&#123; return doPost(url, params,CHARSET); &#125; /** * HTTP Get 获取内容 * @param url 请求的url地址 ?之前的地址 * @param params 请求的参数 * @param charset 编码格式 * @return 页面内容 */ public static String doGet(String url,Map&lt;String,String&gt; params,String charset)&#123; if(url==null||&quot;&quot;.equals(url))&#123; return null; &#125; try &#123; if(params != null &amp;&amp; !params.isEmpty())&#123; List&lt;NameValuePair&gt; pairs = new ArrayList&lt;NameValuePair&gt;(params.size()); for(Map.Entry&lt;String,String&gt; entry : params.entrySet())&#123; String value = entry.getValue(); if(value != null)&#123; pairs.add(new BasicNameValuePair(entry.getKey(),value)); &#125; &#125; url += &quot;?&quot; + EntityUtils.toString(new UrlEncodedFormEntity(pairs, charset)); &#125; HttpGet httpGet = new HttpGet(url); CloseableHttpResponse response = httpClient.execute(httpGet); int statusCode = response.getStatusLine().getStatusCode(); if (statusCode != 200) &#123; httpGet.abort(); throw new RuntimeException(&quot;HttpClient,error status code :&quot; + statusCode); &#125; HttpEntity entity = response.getEntity(); String result = null; if (entity != null)&#123; result = EntityUtils.toString(entity, &quot;utf-8&quot;); &#125; EntityUtils.consume(entity); response.close(); return result; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * HTTP Post 获取内容 * @param url 请求的url地址 ?之前的地址 * @param params 请求的参数 * @param charset 编码格式 * @return 页面内容 */ public static String doPost(String url,Map&lt;String,String&gt; params,String charset)&#123; if(url==null||&quot;&quot;.equals(url))&#123; return null; &#125; try &#123; List&lt;NameValuePair&gt; pairs = null; if(params != null &amp;&amp; !params.isEmpty())&#123; pairs = new ArrayList&lt;NameValuePair&gt;(params.size()); for(Map.Entry&lt;String,String&gt; entry : params.entrySet())&#123; String value = entry.getValue(); if(value != null)&#123; pairs.add(new BasicNameValuePair(entry.getKey(),value)); &#125; &#125; &#125; HttpPost httpPost = new HttpPost(url); if(pairs != null &amp;&amp; pairs.size() &gt; 0)&#123; httpPost.setEntity(new UrlEncodedFormEntity(pairs,CHARSET)); &#125; CloseableHttpResponse response = httpClient.execute(httpPost); int statusCode = response.getStatusLine().getStatusCode(); if (statusCode != 200) &#123; httpPost.abort(); throw new RuntimeException(&quot;HttpClient,error status code :&quot; + statusCode); &#125; HttpEntity entity = response.getEntity(); String result = null; if (entity != null)&#123; result = EntityUtils.toString(entity, &quot;utf-8&quot;); &#125; EntityUtils.consume(entity); response.close(); return result; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; public static void main(String []args)&#123; String getData = doGet(&quot;http://www.baidu.com/&quot;,null); System.out.println(getData); System.out.println(&quot;----------------------分割线-----------------------&quot;); String postData = doPost(&quot;http://www.baidu.com/&quot;,null); System.out.println(postData); &#125;&#125;]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS跨域请求]]></title>
    <url>%2Fjscrossdomain%2F</url>
    <content type="text"><![CDATA[首先js跨域请求是不安全的，可以通过前台调用后台服务器，通过后台httpclient请求url，返回结果。js跨域请求如下：前端js：12345678910111213$.ajax(&#123; async : false, url : url, type : &quot;GET&quot;, dataType : &quot;jsonp&quot;, // 返回的数据类型，设置为JSONP方式 jsonp : &quot;jsonpCallback&quot;, success : function(response) &#123; alert(&quot;请求成功&quot;); &#125;, error : function() &#123; alert(&quot;请求失败&quot;); &#125;&#125;); 后台使用jfinal框架:123String key = getPara(&quot;key&quot;);String jsonpCallback = getPara(&quot;jsonpCallback&quot;);renderJson(jsonpCallback+&quot;(&quot;+json+&quot;)&quot;);]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>javascript</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2Fgitcommand%2F</url>
    <content type="text"><![CDATA[git常用命令1.如何配置你的身份123git config --global user.name &quot;Albert&quot;git config --global user.email &quot;albert@gmal.com&quot; 验证是否配置成功(只需要将最后的名字和邮箱地址去掉即可)123git config --global user.namegit config --global user.email 2.如何创建代码仓库 先进入到项目目录下面,执行命令:git init 仓库创建完成后,会在项目的根目录下生成一个隐藏的.git文件夹,可以通过ls -al命令来查看一下 3.如何提交本地代码 add是用于把想要提交的代码先添加进来,而commit则是真正地去执行提交操作,比如我们想要添加AndroidManifest.xml,可以输入一下命令:git add AndroidManifest.xml 添加目录也是这样,只需将文件名改成目录名即可.git add src 一次性把所有文件都添加好的命令如下:git add . 现在项目所有文件已经添加好了,我们来提交一下,输入如下命令:git commit -m &quot;First commit.&quot; 注意-m参数用来加上提交的描述信息. 4.如何把远程版本库克隆到本地git clone https://github.com/albert567/mobilesafe.git 5.如何将提交的内容同步到远程版本库git push https://github.com/albert567/mobilesafe.git master 同步时GitHub需要输入用户名和密码来进行身份校验. 注意,如果本地第一次同步远程版本库,需要先将远程版本库clone到本地,然后将.git和README.md拷贝到本地项目根目录,再执行add,commit命令 6.如何把文件从版本控制中删掉git rm res/layout/activity_main.xml 7.如何查看状态git status 8.如何查看所有分支git branch -a 9.如何添加分支git branch test //如果 test分支不存在,添加该分支 10.如何切换分支git checkout test //切换到test分支 11.如何删除分支git branch -d test //删除test分支 12.如何查看提交修改记录git log]]></content>
      <categories>
        <category>IT技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
